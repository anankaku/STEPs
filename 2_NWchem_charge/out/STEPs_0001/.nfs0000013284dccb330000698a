#!/usr/bin/env python3
from __future__ import annotations

import re
import argparse
from pathlib import Path

DATA_ROW_RE = re.compile(r"^\s*(\d+)\s+([A-Za-z]+)\s+")

def extract_resp_constrained_charges(resp_out: Path, debug: bool = False) -> list[float]:
    """
    Robust extraction for NWChem RESP output tables like:

    Atom  Coordinates              Charge
    (maybe some header lines with ESP / constr)
    1  C   x y z   q_esp   q_constr
    2  C   x y z   q_esp   q_constr
    ...

    We anchor on the 'Atom' + 'Coordinates' header line, then find the first data row.
    """
    lines = resp_out.read_text(errors="ignore").splitlines()

    # 1) Find a stable anchor near the table header
    anchor_idx = None
    for i, line in enumerate(lines):
        if ("Atom" in line) and ("Coordinates" in line):
            anchor_idx = i
            break

    if anchor_idx is None:
        raise RuntimeError("Could not find table header anchor containing 'Atom' and 'Coordinates'.")

    # 2) From the anchor, find the first data row: "<int> <element> ..."
    start_idx = None
    for j in range(anchor_idx, min(anchor_idx + 2000, len(lines))):
        if DATA_ROW_RE.match(lines[j]):
            start_idx = j
            break

    if start_idx is None:
        if debug:
            snippet = "\n".join(lines[anchor_idx:anchor_idx+30])
            raise RuntimeError(
                "Found 'Atom/Coordinates' header but no data rows after it.\n"
                "Snippet near header:\n" + snippet
            )
        raise RuntimeError("Found header but no data rows after it.")

    if debug:
        print("\n[DEBUG] Header anchor line:")
        print(lines[anchor_idx])
        print("\n[DEBUG] First data row:")
        print(lines[start_idx])
        print("\n[DEBUG] Next few lines:")
        for k in range(start_idx, min(start_idx + 5, len(lines))):
            print(lines[k])
        print()

    # 3) Parse consecutive data rows
    charges: list[float] = []
    for line in lines[start_idx:]:
        if not line.strip():
            break
        if not DATA_ROW_RE.match(line):
            # stop when table ends
            break

        fields = line.split()
        # Expect: idx, element, x, y, z, esp, constr  (>= 7 fields)
        if len(fields) < 7:
            continue

        try:
            # validate index is int (1-based)
            int(fields[0])
            q_constr = float(fields[-1])  # last column
        except ValueError:
            continue

        charges.append(q_constr)

    if not charges:
        raise RuntimeError(
            "Located table start but parsed zero charges. "
            "Check whether the last column is actually 'constr' in your file."
        )

    return charges


def parse_indices_1based(s: str) -> set[int]:
    parts = re.split(r"[,\s]+", s.strip())
    out: set[int] = set()
    for p in parts:
        if p:
            out.add(int(p) - 1)  # convert to 0-based
    return out


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("resp_output", help="Path to NWChem RESP output file (e.g. R20_RESP.output)")
    ap.add_argument("-o", "--out", default="R20charge.dat", help="Output charge file")
    ap.add_argument("--debug", action="store_true", help="Print where the table was detected")
    args = ap.parse_args()

    resp_path = Path(args.resp_output).expanduser()
    if not resp_path.exists():
        raise SystemExit(f"[ERROR] File not found: {resp_path}")

    charges_all = extract_resp_constrained_charges(resp_path, debug=args.debug)
    n = len(charges_all)
    print(f"[OK] Parsed {n} charges from RESP table.")

    cap_input = input("Cap atom indices to REMOVE (1-based, space/comma separated): ").strip()
    cap0 = parse_indices_1based(cap_input)

    bad = sorted(i + 1 for i in cap0 if i < 0 or i >= n)
    if bad:
        raise SystemExit(f"[ERROR] These indices are out of range (1..{n}): {bad}")

    keep = [q for i, q in enumerate(charges_all) if i not in cap0]

    print("\n=== Summary ===")
    print(f"Removed atoms : {len(cap0)}")
    print(f"Remaining    : {len(keep)}")
    print(f"Sum(all)      = {sum(charges_all):+.6f}")
    print(f"Sum(remaining)= {sum(keep):+.6f}")

    ndp_raw = input("Round decimals? (blank = no rounding; e.g., 4): ").strip()
    if ndp_raw:
        ndp = int(ndp_raw)
        keep = [round(q, ndp) for q in keep]

    out_path = Path(args.out).expanduser()
    out_path.write_text("\n".join(f"{q:.10f}" for q in keep) + "\n")
    print(f"\n[DONE] Wrote {len(keep)} charges to {out_path}\n")


if __name__ == "__main__":
    main()
